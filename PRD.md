# 제품 요구사항 문서 v7.3: 통합 마스터 플랜

> **[중요] 문서 원칙:**
> 이 문서는 프로젝트의 **단일 진실 공급원(Single Source of Truth)** 입니다.
> 과거 프로젝트(`prd_bak.md`, `prd_v6.0_backup.md`)의 모든 요구사항, 아키텍처 결정, 개발 경험을 통합한 마스터 플랜으로서, 모든 개발은 이 문서를 기준으로 합니다.

---

## 1. 프로젝트 비전 및 목표

### 1.1. 비전

이 프로젝트는 단순한 트레이딩 봇을 넘어, **사용자 중심의 확장성을 갖춘 지능형 자동매매 플랫폼**을 구축하는 것을 목표로 합니다. 기술적 우위와 강력한 사용자 커뮤니티를 모두 갖춘 독보적인 플랫폼으로 성장하는 것을 지향합니다.

### 1.2. 핵심 목표

- **유연성 및 확장성:** 다양한 금융 시장(암호화폐, 주식 등)과 트레이딩 전략을 수용할 수 있는 유연하고 설정 기반의 프레임워크를 제공합니다.
- **재사용성 및 유지보수성:** 명확한 관심사 분리 원칙에 따라 모듈형 아키텍처를 구축하여, 코드의 재사용성을 높이고 유지보수를 용이하게 합니다.
- **사용자 중심:** 파이썬 프로그래밍 경험이 있는 초보 개발자나 퀀트 트레이더가 직관적으로 사용할 수 있는 강력한 웹 인터페이스를 제공하여, 복잡한 전략을 쉽게 생성하고 관리할 수 있도록 돕습니다.
- **데이터 기반 의사결정:** 강력한 백테스팅과 리스크 관리 도구를 제공하여, 사용자가 감정이 아닌 데이터에 기반한 합리적인 트레이딩 의사결정을 내릴 수 있도록 지원합니다.

---

## 2. 핵심 설계 원칙

- **명확한 관심사 분리 (Separation of Concerns):** 시스템의 모든 구성 요소(프론트엔드, 백엔드 API, 스캔 엔진, 브로커 등)는 각자 명확히 구분된 하나의 책임만 갖도록 설계하여 독립적인 개발과 수정을 보장합니다.

- **'코드 재사용성'과 '전략 이식성'의 분리 (재정립된 핵심 원칙):**
- **배경:** '모든 브로커를 지원하는 유연한 플랫폼'이라는 비전과 '특정 브로커의 고유 기능을 최대로 활용하고 싶은 사용자 요구'가 상충하는 문제를 해결하기 위해, '마켓 비의존성'이라는 추상적 목표를 아래와 같이 두 개의 구체적인 원칙으로 재정립합니다.
- **원칙 1: '코드 재사용성(Code Reusability)'은 필수 목표입니다.**
- 스캔 엔진, API 서버, UI 컴포넌트 등 플랫폼의 핵심 코드는 단 한 번만 작성됩니다. 우리는 '업비트용 프로그램', 'KIS용 프로그램'을 별도로 만들지 않습니다. 이는 '브로커 패턴'을 통해 달성되며, 새로운 브로커 추가 시 해당 브로커의 API와 통신하는 '어댑터' 코드만 추가할 뿐, 핵심 로직은 절대 변경되지 않습니다.
- **원칙 2: '전략 이식성(Strategy Portability)'은 사용자의 '선택'입니다.**
- 모든 전략이 모든 브로커에서 동작해야 할 의무는 없습니다. 대신, 사용자가 목적에 따라 두 가지 종류의 전략을 만들 수 있도록 지원합니다.
1. **이식 가능 전략 (Portable Strategy):** 모든 브로커에서 공통으로 지원하는 '표준 기능'만을 사용하여 만든 전략. 이 전략은 여러 마켓에서 재사용될 수 있습니다.
2. **브로커 최적화 전략 (Broker-Optimized Strategy):** 특정 브로커만 제공하는 고유하고 강력한 기능(예: 특정 필터, 전용 보조지표)을 활용하여 최고의 성능을 추구하는 전략. 이 전략은 해당 브로-커에 종속됩니다.
- **구현 아키텍처: '명시적 컨텍스트'**
- 위 원칙을 구현하기 위해, **'전략 생성 시점에 명시적으로 컨텍스트(Broker/Market)를 정의'** 하는 아키텍처를 채택합니다. 모든 `Strategy` 객체는 `broker`와 `market` 속성을 필수로 가지며, UI는 선택된 컨텍스트에 맞춰 사용 가능한 기능 목록을 동적으로 제공합니다. 스캔 엔진은 실행 시점에 컨텍스트 일치 여부를 검증하여 호환되지 않는 전략의 실행을 원천 차단합니다.

- **웹 인터페이스 우선 개발:** 초기 단계부터 백엔드 API와 프론트엔드 UI를 함께 구축하여, 사용자에게 통합된 고품질의 경험을 제공하는 것을 최우선으로 합니다.

- **최신 안정화 기술 스택 유지:** 항상 커뮤니티에서 검증된 가장 최신 안정화 버전의 기술을 사용하여 최고의 성능과 보안을 확보합니다.

---

## 3. 사용자 페르소나 및 시나리오

- **사용자 페르소나:** 파이썬 프로그래밍 경험이 있는 초보개발자 또는 퀀트 트레이더. 이들은 기술적 깊이가 있지만, 복잡한 설정 없이 직관적인 UI를 통해 빠르게 자신의 아이디어를 전략으로 만들고 검증하고 싶어합니다.

- **주요 사용자 흐름:**
1. **설정:** 사용자는 `.env` 파일에 자신의 거래소 API 키를 입력합니다.
2. **전략 생성:** 웹 브라우저에서 **'전략 빌더'** 페이지에 접속하여, 시각적인 인터페이스를 통해 실시간 필터와 심층 분석 규칙을 조합하여 자신만의 정교한 전략을 만들고 저장합니다.
3. **실행 및 모니터링:** UI에서 '스캔 시작'을 누르면 봇이 실시간으로 종목을 탐색합니다. 결과는 웹소켓을 통해 화면에 즉시 업데이트됩니다.
4. **분석:** 발견된 종목을 클릭하여 '차트 분석 페이지'에서 상세한 시각적 분석을 수행합니다.
5. **매매 실행:** 분석이 완료된 종목에 대해, '개별 상세 분석 페이지'의 인터페이스를 통해 직접 매수/매도 주문을 실행하거나 자동매매 로직을 활성화합니다.

---

## 4. 중무장 개발 5대 원칙 (The 5 Principles of Armored Development)

1. **API 계약 우선 개발 (API Contract-First)**
* **문제:** 백엔드와 프론트엔드 간의 끝없는 데이터 구조 불일치.
* **해결책:** 코딩 시작 전, **OpenAPI(Swagger) 명세 파일 (`openapi.json`)** 로 전체 API의 요청/응답 형식을 확정합니다. 이 파일이 백엔드와 프론트엔드 간의 '법적인 계약'이 됩니다.

2. **격리 기반 테스트 전략 (Isolation-Based Testing Strategy)**
* **원칙:** "하나의 수정이 다른 곳에서 버그를 일으키는 '회귀' 현상"을 방지하기 위해, 시스템의 각 부분을 독립적으로 검증하고 계층적으로 통합하며 테스트한다.
* **백엔드 테스트 전략 (`pytest`):**
* **단위 테스트:** 가장 작은 논리 단위의 정확성을 검증. (예: 개별 지표 계산, 파서 로직)
* **실행 시점:** 개발 중 수시로, 커밋 전, 그리고 CI 파이프라인에서(`push`/`pull request` 시) 자동으로 실행.
* **통합 테스트:** 여러 컴포넌트의 상호작용을 검증. (예: API 엔드포인트 전체 흐름)
* **실행 시점:** 주요 기능 개발 완료 후, 그리고 `main` 브랜치 병합 전 CI 파이프라인에서 자동으로 실행.
* **프론트엔드 테스트 전략:**
* **컴포넌트 테스트 (`Storybook`):** 개별 UI 컴포넌트를 시각적으로 검증.
* **실행 시점:** UI 컴포넌트 개발/수정 시 개발 과정의 일부로 수시 확인.
* **통합 테스트 (`React Testing Library` + `MSW`):** 페이지 단위 기능과 사용자 상호작용을 검증.
* **실행 시점:** 페이지 기능 개발 시, 그리고 CI 파이프라인에서 자동으로 실행.
* **E2E 테스트 전략 (`Cypress` 또는 `Playwright`):**
* **목표:** 실제 사용자의 입장에서 핵심 시나리오 전체가 문제없이 동작하는지를 최종적으로 검증.
* **필수 검증 시나리오:** 전략 생성, 스캔 실행 및 결과 확인, 동적 UI 검증 등.
* **실행 시점:** 운영 서버 배포 직전, 또는 주기적으로 자동 실행.

3. **개발 환경: 의존성 격리 및 버전 고정**
* **문제:** "제 PC에서는 되는데요?" - 개발자마다 다른 환경으로 인한 예측 불가능한 버그.
* **해결책:** 복잡한 가상화 도구(Docker 등)에 대한 의존성을 제거하고, 기본 제공되는 가상 환경과 의존성 관리 도구를 통해 개발 환경의 일관성을 '코드 레벨'에서 엄격하게 확보한다. 이는 개발 에이전트의 독립적인 작업 수행을 보장하기 위함이다.
* **Python 환경:** `venv` 가상 환경 및 `requirements.txt`를 통한 버전 고정.
* **Node.js 환경:** `package-lock.json` 및 `npm ci`를 통한 버전 고정.

4. **지속적 통합 (Continuous Integration, CI)**
* **문제:** 실수가 포함된 코드가 메인 브랜치에 병합되어 전체 안정성을 해치는 상황.
* **해결책:** **`GitHub Actions`** 를 설정하여, 모든 코드 변경사항(`push` 또는 `pull request`)에 대해 코드 스타일 검사, 테스트, 빌드 작업을 자동으로 수행하고, 통과하지 못하는 코드는 병합을 금지합니다.

5. **구조화된 로깅 및 관측 가능성 (Structured Logging & Observability)**
* **문제:** 에러 발생 시, `print()` 디버깅에 의존하여 원인 파악이 오래 걸림.
* **해결책:** `structlog`(백엔드), `Sentry`(프론트엔드) 등을 도입하여 모든 로그와 에러를 구조화된 데이터로 기록하고 중앙에서 수집합니다.

---

## 5. 아키텍처 및 기술 스택

### 5.1. 기술 스택
- **원칙:** 항상 커뮤니티에서 검증된 **가장 최신 안정화 버전(Latest Stable Version)**의 기술 스택을 유지합니다.
- **Backend:** FastAPI (Python)
- **Data Analysis:** Polars
- **Frontend:** React (TypeScript) with SWC Compiler & Vite/Rollup
- **Database:** SQLite (초기), PostgreSQL (확장)
- **Real-time Communication:** WebSockets

### 5.2. 프로젝트 구조 (목표 아키텍처)

`tbot/
├── app/ # FastAPI 백엔드 애플리케이션
│ ├── api/ # API 엔드포인트 (라우터)
│ ├── core/ # 핵심 비즈니스 로직 (웹에 비의존적)
│ │ ├── brokers/ # 브로커 인터페이스 및 구현체
│ │ └── engine.py # 스캔 엔진
│ ├── models/ # Pydantic 데이터 모델
│ ├── services/ # API와 핵심 로직을 연결하는 서비스 계층
│ └── main.py # FastAPI 앱 시작점
├── frontend/ # 프론트엔드 애플리케이션 (React)
├── plugins/ # 사용자 정의 플러그인 디렉토리
│ ├── indicators/ # 보조지표 플러그인
│ └── notifiers/ # 알림 플러그인
├── tests/ # 테스트 코드
├── .env # 환경 변수 (API 키 등)
└── prd.md`

### 5.3. 다중 마켓/브로커 지원 아키텍처: '브로커 패턴'
- **목표:** 여러 거래소를 지원할 때, 핵심 로직의 변경 없이 확장할 수 있는 유연한 구조를 마련합니다.
- **설계:** `BaseBroker` 추상 클래스를 정의하고, 거래소별로 이를 상속받아 구현체를 만듭니다. `BrokerFactory`를 통해 중앙에서 객체를 생성하여 다른 모듈과의 의존성을 분리합니다.

### 5.4. 동적 플러그인 아키텍처
- **목표:** 사용자가 직접 만든 보조지표나 알림 모듈을 안전하게 추가할 수 있도록 합니다.
- **설계:** `plugins/` 폴더를 기반으로, 시스템 시작 시 `importlib`을 통해 유효한 플러그인만 동적으로 로드하고 오류는 격리합니다.

### 5.5. 사용자 인증 및 권한 부여 (JWT & RBAC) - v2.0+
- **목표:** 다중 사용자 환경을 지원하고 사용자별 데이터를 격리합니다.
- **설계:** 상태 비저장(Stateless) 방식인 JWT를 통해 인증하고, 사용자별 `role`을 부여하여 API 접근 권한을 제어(RBAC)합니다.
- **개발 우선순위:** 초기 버전에서는 단일 사용자 환경을 가정하고 개발을 진행하며, 사용자 인증 및 다중 사용자 지원은 v2.0 이후의 핵심 확장 기능으로 계획합니다.

### 5.6. 배포 전략 (Deployment Strategy)
- **목표:** 사용자가 언제 어디서든 웹 브라우저만으로 안정적인 서비스에 접속할 수 있도록 합니다.
- **전략:** 최종 애플리케이션은 **Docker 및 Docker Compose**를 사용하여 서버에 배포하는 것을 원칙으로 합니다.
- **설명:** 이 방식은 개발 환경과 거의 동일한 환경을 서버에 복제하여 "제 PC에선 됐는데 서버에선 안돼요" 문제를 원천적으로 방지합니다. 배포 시에는 사용자의 화면을 그리는 '프론트엔드'와 실제 모든 계산을 처리하는 '백엔드'가 하나의 세트로 묶여 서버에 설치되고 24시간 실행 상태를 유지하게 됩니다.

### 5.7. 실시간 통신 아키텍처 (WebSocket)

**1. 목표**
HTTP 폴링 방식의 비효율을 제거하고, 스캔 진행 상황, 실시간 시세 등 동적인 데이터를 사용자에게 즉시 전달하여 생동감 있는 사용자 경험을 제공한다.

**2. 연결 엔드포인트 및 인증**
* 클라이언트는 단일 엔드포인트 `/ws/v1/updates` 를 통해 서버와 WebSocket 연결을 수립한다.
* **인증:** 연결 시, 쿼리 파라미터로 JWT Access Token을 전달해야 한다. (예: `/ws/v1/updates?token=JWT_TOKEN_HERE`) 서버는 토큰 유효성 검증 후 연결을 수락하며, 유효하지 않을 경우 연결을 거부한다.

**3. 표준 메시지 구조 (Envelope)**
* 서버와 클라이언트가 주고받는 모든 메시지는 다음과 같은 표준 JSON 구조를 따른다.
```json
{
"event": "이벤트_이름",
"payload": { /* 실제 데이터 */ }
}
```

**4. 핵심 이벤트 종류 및 `payload` 명세 (서버 → 클라이언트)**

* **`scan_status_update`**: 스캔의 전반적인 상태(시작, 중지, 완료, 오류) 변경 시 발생.
* `payload`: `{"strategy_id": 1, "status": "RUNNING" | "STOPPED" | "COMPLETED" | "ERROR", "message": "스캔이 시작되었습니다."}`

* **`scan_progress_update`**: 2차 스캔의 상세 진행률을 실시간으로 업데이트.
* `payload`: `{"strategy_id": 1, "processed": 25, "total": 100, "progress": 25.0}`

* **`scan_result_found`**: 전략에 의해 새로운 종목이 검출되었을 때 실시간으로 전송.
* `payload`: `{"strategy_name": "내 전략", "ticker": "KRW-BTC", "timestamp": "2024-11-08T12:00:00Z", "details": {"price": 70000000, "volume": 12.34}}`

* **`chart_data_update`**: '개별 상세 분석 페이지'의 실시간 데이터(현재가, 체결, 호가창) 업데이트.
* `payload`: `{"ticker": "KRW-BTC", "type": "trade" | "orderbook", "data": { ... }}`

* **`notification`**: 시스템 전반의 사용자 알림 또는 오류 메시지 전송.
* `payload`: `{"level": "info" | "warning" | "error", "message": "API 키가 유효하지 않습니다."}`

**5. 구독 모델 (클라이언트 → 서버)**
* 클라이언트는 연결 후, 원하는 데이터 스트림을 선택적으로 받아보기 위해 '구독' 메시지를 서버로 전송한다.
* **`subscribe`**: 특정 데이터 구독 요청. (`event`: `subscribe`, `payload`: `{"channel": "chart", "ticker": "KRW-BTC"}`)
* **`unsubscribe`**: 구독 해지. (`event`: `unsubscribe`, `payload`: `{"channel": "chart", "ticker": "KRW-BTC"}`)

---

## 6. 기능 요구사항

### 6.1. 2단계 스캔 동작 방식
- **1차 스캔:** Upbit과 같은 거래소에서 제공하는 데이터 API를 통해 모든 종목의 *현재 시점 OHLCV, 거래대금, 시가총액 등 기본 데이터*를 한꺼번에 수신한다. 전략 빌더에서 구성된 수식 중 지표 및 `shift` 함수를 제외한 기본 조건(예: 거래대금, 시가총액 등)만을 사용하여 이 데이터를 기반으로 전체 시장 또는 선택된 관심종목을 대상으로 빠르게 종목을 필터링한다. (여기서 `v`는 거래량, `m`은 거래대금을 의미함)
- **2차 스캔:** 1차 스캔에서 필터링된 종목들을 대상으로, 전략에 사용된 지표(예: 120일 이동평균선)가 필요로 하는 **최대 기간만큼의 과거 OHLCVM 시계열 데이터를 동적으로 요청하여 수신**한다. (예: `ma(120)` 사용 시 최소 120개 이상의 봉 데이터 확보) 이 데이터를 기반으로 전략 빌더에서 구성된 전체 수식(지표 및 `shift` 함수 포함)을 적용하여 정밀 분석을 수행한다.

### 6.2. 전략 빌더 UI/UX 상세 명세 (v1.1 최종)

**핵심 워크플로우:**

- **클릭 기반 인터페이스:** 팔레트의 모든 아이템(지표, 연산자 등)은 드래그 앤 드롭이 아닌 **클릭**을 통해 캔버스에 추가된다.
- **드래그 앤 드롭:** 드래그 앤 드롭은 **캔버스 내에서** 아이템의 순서를 변경하는 용도로만 사용된다.
- **지표의 변수화:** 지표는 캔버스에 직접 추가되지 않는다. 대신, 팝업 모달을 통해 파라미터와 소스를 설정한 후, **새로운 변수로 저장**된다. 이 저장된 변수가 팔레트의 'Variables' 목록에 추가되며, 사용자는 이 변수를 클릭하여 캔버스에서 사용한다.

**표현식 문법 및 변수 명명 규칙:**

* **복합 표현식 지원:** 조건식의 비교 연산자(`>`, `<` 등) 양쪽에는 여러 지표나 값을 조합한 복잡한 수식을 사용할 수 있습니다.
* **(예시):** `trix(12) - trix_signal(9) > 0`

* **함수 연결(Chaining) 제약:** 백엔드 파서의 안정성과 명확성을 위해, 함수 호출의 결과에 직접 `.`을 찍어 다른 함수(예: `shift`)를 연결하는 것은 허용되지 않습니다.

* **변수 활용 규칙:** 위와 같은 함수 연결을 사용하려면, 반드시 먼저 해당 지표를 **괄호 `()`가 없는 변수**로 저장한 후 사용해야 합니다.
* **잘못된 사용법:** `trix(12).shift(1) > 0`
* **올바른 사용법:**
1. 먼저, 지표 설정 모달을 통해 `trix(12)`의 결과를 `trix12` 라는 변수로 저장합니다.
2. 그 다음, 저장된 변수를 사용하여 조건을 작성합니다: `trix12.shift(1) > 0`

**컴포넌트별 상세 명세:**
0. **로그인 (v2.0+):**
- **(초기 버전 제외)** 향후 다중 사용자 지원 시 구현될 기능입니다.
- 프로그램 실행시 첫페이지. 가운데 아이디 패스워드 를 적을수 있는 칸이 있고 로그인 버튼이 있음.

1. **전체 레이아웃:**
- 페이지 전체를 **상하 수직 구조**로 한다. 쓰여진 순서대로 아래로 구성한다
- 배치 순서: 아래의 순서대로 페이지를 구성
- `Strategy Management` `Dashboard` `Analysis` `Strategy Builder` 순으로 핵심 페이지 링크가 상단 네비게이션 바에 항상 표시됩니다. 클릭 시 해당 페이지로 이동합니다.

2. **Strategy Management**
2.1 매니지 명을 쓸수 있는 칸이 있고 옆에 기존 작성된 전략을 동적으로 불러올수 있는 드롭다운 리스트 옆에 반복 간격을 정할수 있는 버튼 옆에 SAVE, SAVEAS, EDIT, DEL 하는 버튼을 만든다.
2.2 표 작성
- 브로커. 마켓. 매니지명. 활성 비활성 체크버튼. 검색 종목수. 생성일. 수정일.

3. **Dashboard**
3.1 표작성
- 종목명. 브로커. 매니지명(복수가능). 전일대비 상승률. 당일 거래대금. ohlc미니바
- 종목명 클릭시 상세페이지로 이동
- 전일대비 상승률. 당일 거래대금. ohlc미니바는 실시간 데이터를 보여줘야함.

4. **Analysis **
4.1 Strategy Builder 에서 작성할때 쓰여진 주기의 차트가 보여짐. 만약 주봉 90분봉이 쓰였다면 여기서도 두개의 차트가 생겨야하고 전략에서 쓰였던 지표나 기본값A 등이 같이 표현이 되어야한다.
4.2 하단에 매매 전략에서 쓰여진 내용이 차트에 반영이 될수 있어야한다.

5. **Strategy Builder**
5.0.1 **1차 스캔**
- 목표 : 거래소에서 지원하는 모든종목의 ohlcvm 을 한파일 또는 웝소켓으로 지원해주는 단일데이터를 이용하여 빠르게 종목들을 검색 한다
5.0.2 **2차 필터링**
- 목표 : 1차스캔에서 필터링된 종목들의 현재기준 과거 봉들의 시계열 데이터를 불러와 2차 캔버스에서 작성된 조건에 맞는 종목을 필터링 한다. 그리고 그 데이터를 Strategy Management Dashboard Analysis에서 쓸수 있게한다
5.1. **팔레트 (Toolbar):**
- **수평 툴바 형태**로 페이지 상단에 위치한다.
- **1차/2차 스캔**버튼
.1차 선택시 지표 쉬프트 기능 비활성화 그리고 거래소에서 지원하지 않는 주기 비활성화
.1차를 선택했다면 이후 팔래트내 버튼 클릭은 1차 캔버스에 입력됨. 2차 버튼은 2차 캔버스로 입력
- **지표 (Indicators):**
- 마지막에 사용한 지표를 기본 버튼으로 표시한다.
- 그 외 지표들은 옆의 드롭다운(▼) 메뉴를 통해 선택할 수 있다.
- 지표 버튼 클릭 시, '지표 설정 모달'이 열린다.
- **기본데이터 (BasicData):** : 모두 버튼화
- `open`, `high`, `low`, `close`,`volume`,`amount`
- **연산자 (Operators):**
- 아래 데이터를 최대한 연관성있는 짝끼리 맞추어 표시한다.
- **사칙연산:** `+`, `-`, `*`, `/`
- **비교연산:** `>`, `>=`, `<`, `<=`, `==`, `!=`
- **논리연산:** `AND`, `OR`,`(`,`)`
- **크로스:** `cross_up`, `cross_down`
- **숫자 (Numbers):**
- 기존에 생성된 숫자 버튼 목록을 표시한다.
- 옆의 입력 필드에 새 숫자를 입력하고 Enter를 누르면, 해당 숫자가 새 버튼으로 목록에 추가됨과 동시에 캔버스에도 추가된다.
- **변수 (Variables):**
- '지표 설정 모달'에서 생성된 변수들의 목록을 버튼 형태로 표시한다.
- 각 변수 버튼 위에 마우스를 올리면, 해당 변수가 담고 있는 수식(expression)이 툴팁(말풍선)으로 표시된다.
- **함수 (Functions):**
- **`shift(n)`:** 'shift' 버튼 클릭 시, 캔버스에 `shift()` 토큰이 추가됩니다. 사용자는 괄호 안에 직접 이동할 캔들 수를 입력할 수 있습니다. (예: `shift(1)`)
- **`cross_up(A, B)`:** 'cross_up' 버튼 클릭 시, `cross_up( , )` 토큰이 추가됩니다. 사용자는 두 개의 인자(A와 B)를 캔버스에서 드래그 앤 드롭하거나, 팔레트의 다른 요소를 클릭하여 채울 수 있습니다. `cross_down`도 동일한 방식으로 동작합니다.
- **if, elseif, then** : 조건식을 만들고 조건에 충족 했을때 값(ohlcvm 변수들)을 변수에 저장할수 잇도록 함수 추가
5.1.1. **지표 설정 모달 (IndicatorModal):**
- 지표함수의 입력변수와 출력변수 갯수 및 내용을 정확히 지키고 출력변수를 선택후 변수에 저장할수 있게 한다
- **소스(Source) 선택:** 지표 계산에 사용될 데이터 소스를 선택하는 드롭다운 메뉴를 추가한다.
- **기본 소스:** `close`, `open`, `high`, `low`, `volume`, `amount`
- **사용자 정의 변수:** 'Variables' 목록에 있는 변수들
- **변수 이름 입력:** 설정된 지표를 저장할 새 변수의 이름을 입력하는 텍스트 필드를 추가한다.
- **저장 버튼:** 'Add to Canvas' 버튼을 '**Save as Variable**'로 변경한다. 클릭 시, 설정된 내용으로 새 변수를 생성하고 모달을 닫는다.
5.2.1. **미리보기**
- 1차캔버스 와 2차 캔버스에서 작성된 수식이 읽기전용으로 깨끗하게 보여짐 (ex, "A and ( B or C )" )
5.2.2 **1차 캔버스** - 함수를 이용하여 변수를 만드는 또는 주기를 정하여 조건식을 정하는 칸. 변수명을 입력할수 있는 칸이 잇어야 한다.
- 팔레트에 있는 모든 버튼들이 클릭이 되면 여기에 가로로 표시가 되고 마우스로 순서를 변경할수 있게 하며 버튼마다 x 표시가 있어 필요없을경우 클릭하여 지운다. 조건식이 완성되면 주기(월 주 일 분) 을 선택하여 변수명을 저장하여 이 변수를 최종캔버스에서 사용한다 이 기능은 사용자가 조건식을 만들때 주기를 섞어서 쓰지 안게 하기 위함이다. 월 주기를 이용한 변수 A 와 10분봉 에서의 조건 변수 B를 최종 캔버스에서 A and B 와 같이 씀으로서 월봉 조건에 맞는 종목과 10분봉 조건에 맞는 종목만 필터링 하기 위함이다 그리고 조건식이 만족했을때 종가 등의 수치를 변수로 저장하는 기능도 포함 해야 된다. 이 기능이 기준선A 이다
- 조건식 변수명을 지을수 있는 박스 옆에 SAVE, SAVEAS 버튼 옆에 주기드롭박스
- 팔레트등에서 클릭하면 버튼이 생성되는 칸

5.2.3 **2차 캔버스** - 최종 조건식을 만듬. 변수명 지정 과 주기지정 외에 모든 기능은 1차 캔버스와 동일함.

6. **스캔 실행 및 결과 표시:**
- 캔버스 아래에 'Run Scan' 버튼이 추가된다.
- 'Run Scan' 버튼 클릭 시, 캔버스에 구성된 수식을 백엔드 API (`/api/v1/scans/run-dynamic`)로 전송하여 스캔을 실행한다.
- **스캔 대상 선택:**
- 'Run Scan' 버튼 좌측에 **"스캔 대상"**을 선택할 수 있는 드롭다운 메뉴를 추가한다.
- **기본값:** `전체 시장 (1차 스캔 결과)`
- **선택 옵션:**
- `전체 시장 (1차 스캔 결과)`
- `--- 관심종목 ---` (구분선)
- 저장된 관심종목 목록 (예: `나의 주도주`, `장기 투자 종목`)
- 선택된 대상에 따라 2차 스캔의 입력 종목이 결정된다.
- **1차 스캔 결과:** 간단히 검출된 종목의 개수만 표시한다. (예: "X 종목 검출" 또는 버튼에 갯수 표시)
- **최종 스캔 결과:**
- 테이블 형태로 표시된다.
- 컬럼: `종목명`, `코드명`, `현재가`, `거래대금(억단위)`, `OHLC 미니바`

7. **전략 관리 및 시장 선택 기능:**
- **전략 저장,수정 등:** 현재 구성된 전략에 이름을 부여하고 드롭다운기능을 넣어서 기존 전략을 불러올수 있게 하고. 그 옆에 8, EDIT, DEL 하는 버튼을 만든다.
- **시장 선택:** `StrategyBuilderPage` 최상단에 자산 유형, 거래소, 기준 통화를 선택하는 UI를 구현하고, 선택된 시장에 따라 빌더의 구성요소가 동적으로 변경되도록 한다.(<코인:빗썸, 업빗트, 코인원, 바이낸스 등 / KRW, USD> , <주식: 한국투자증권, 키움증권, 등 / 국내, 해외(일본,중국,홍콩,등)>, <선물: 키움증권,한국투자증권, 등 /국내, 해외(화폐, 원자재, 등)>

### 6.3. 전략 관리 페이지 상세 명세

1. **전략 목록 및 불러오기:** 저장된 모든 전략의 목록을 표시하고, 선택 시 전략 빌더로 로드하여 수정할 수 있다.
2. **스케줄링 설정:**
- **실행 방식:** `한 번만 실행`, `반복 실행` 선택.
- **스케줄 상세:** `일정 간격` (예: 5분마다) 또는 `일정 시각` (예: 매주 월요일 09:00) 설정.
3. **전략 실행 제어:** 스케줄에 따른 실행 시작/중지 및 즉시 실행 기능을 제공한다.
4. **실행 상태 모니터링:** 각 전략의 상태(`실행 중`, `대기 중` 등)와 최근 실행 결과를 표시한다.
5. **전략 삭제:** 저장된 전략을 삭제한다.

### 6.4. 실시간 대시보드 상세 명세

1. **실시간 스캔 결과 표시:** 실행 중인 모든 전략에 의해 검출된 종목을 실시간으로 목록에 표시한다. (검출 전략, 시각 포함)
2. **핵심 데이터 요약:** 검출 종목의 실시간 체결대금, 기준가A와의 이격도 등 핵심 데이터를 요약하여 표시한다.
3. **상세 분석 연결:** 종목 클릭 시 '개별 상세 분석 페이지'로 이동한다.
4. **관심종목 관리:** 검출 종목을 관심종목에 추가/관리하는 기능을 제공한다.
5. **Discord 알림:** 종목 검출, 매매 체결 등 주요 이벤트 발생 시 Discord로 알림을 전송한다.

### 6.5. 스캔 결과 연동 및 실시간 트레이딩 (v1.2)

1.  **스캔 결과 연동:** 스캔 결과 테이블의 종목을 클릭하면 '개별 상세 분석 페이지'로 이동한다. 이때 해당 종목에 대해 가장 최근에 결정된 **'기준선 A'** 값이 함께 전달된다.

2.  **기준선 A (Baseline A) 상세 정의:**
    *   **정의:** '기준선 A'는 사용자가 전략 빌더에서 `if` 문 등을 사용하여 정의한 **특정 조건이 충족되었을 때의 값**을 저장하는 변수이다.
    *   **데이터 타입:** 종가(`close`), 시가(`open`)와 같은 기본 데이터(OHLCVM)는 물론, `macd(12,26,9)`와 같은 보조지표의 계산 결과 등 모든 숫자 데이터를 저장할 수 있다.
    *   **스코프:** '기준선 A'는 **종목별, 타임프레임별**로 독립적으로 생성되고 관리된다.
    *   **활용:** 저장된 '기준선 A' 값은 다른 조건식에서 비교 값으로 재사용되거나, 아래 설명될 고급 자동매매 로직의 핵심 기준으로 사용된다.

3.  **개별 상세 분석 페이지:**
    *   **동적 실시간 차트:** 다양한 시간 주기의 실시간 차트를 조회하고, 차트 위에 현재 보유 포지션, 평균 매입단가, '기준선 A', 현재 실행중인 자동매매 주문 등을 시각적으로 표시한다.
    *   **실시간 데이터 연동:** WebSocket을 통해 현재가, 호가창, 체결 내역 등을 실시간으로 표시한다.
    *   **수동 매매 인터페이스:** 시장가, 지정가 등 다양한 주문을 실행할 수 있는 UI를 제공한다.
    *   **진보된 자동 매매 기능 (기준선 A 기반 평균단가 관리):**
        *   **사용자 설정:** 사용자는 '총 투자금', '호가 잔량 대비 주문 비율(%)' 등의 변수를 설정한다.
        *   **자동매매 시작:** 사용자가 '자동매매 시작' 버튼을 클릭하면, 시스템은 다음 로직에 따라 자동으로 매매를 실행한다.
        *   **1단계 (초기 매수):**
            *   **조건:** 현재가가 '기준선 A'보다 높아지는 시점에 발동한다.
            *   **실행:** 조건 충족 시점의 매도 호가창을 분석하여, 해당 호가의 총 매도 잔량 중 사용자가 설정한 비율(예: 10%)만큼의 수량을 즉시 매수한다.
        *   **2단계 (평균단가 관리 - 자동 물타기):**
            *   **조건:** 초기 매수가 일부라도 체결되고, 현재가가 보유 포지션의 평균 매입단가보다 낮은 상태일 때 발동한다.
            *   **실행:** 시스템은 현재 포지션의 평균 매입단가를 '기준선 A'와 일치시키기 위해 필요한 추가 매수 가격과 수량을 계산한다. 그 후, 계산된 가격 근처의 하단 매도 호가창을 분석하여, 해당 호가 잔량의 설정된 비율(예: 10%)만큼 지정가 매수 주문을 제출한다. 이 과정은 평균 매입단가가 '기준선 A'에 근접할 때까지 반복된다.
        *   **3단계 (자동 중지 및 정리):**
            *   **조건:** 지속적인 자동 물타기를 통해, 보유 포지션의 **평균 매입단가가 '기준선 A' 이하로 낮아지는 순간** 발동한다.
            *   **실행:** 조건 충족 시, 모든 추가 매수 로직을 즉시 중단하고, 아직 체결되지 않은 모든 하단의 지정가 매수 주문을 **자동으로 취소**한다.
        *   **실시간 모니터링:** 사용자는 이 모든 자동매매 과정(목표 기준선, 현재 평균단가, 대기 중인 주문 목록 등)을 페이지에서 실시간으로 확인할 수 있다.

### 6.6. 매매 관리 페이지 상세 명세

1.  **페이지 목적:** 사용자가 자신의 모든 매매 활동과 자산 현황을 중앙에서 종합적으로 파악하고 관리할 수 있는 전용 대시보드를 제공한다.

2.  **컴포넌트 구성:**
    *   **계좌 총괄 현황 (Summary):**
        *   **총 투자 원금:** 모든 매매에 사용된 총 원금을 표시한다.
        *   **총 평가 자산:** 현재 보유 중인 모든 자산의 실시간 가치를 합산하여 표시한다.
        *   **총 손익 (P&L):** 총 실현 손익과 미실현 손익을 구분하여 표시한다. (예: `+1,500,000 (미실현: +1,200,000 / 실현: +300,000)`)
    *   **보유 종목 현황 (Open Positions):**
        *   **테이블 형식**으로 현재 보유 중인 모든 종목의 목록을 표시한다.
        *   **컬럼:** `종목명`, `보유 수량`, `평균 매입가`, `현재가`, `평가 금액`, `미실현 손익`, `수익률(ROI)`
        *   **액션 버튼:** 각 행의 끝에 해당 종목을 즉시 **전량 매도(시장가)**할 수 있는 `포지션 종료` 버튼을 제공한다.
    *   **매매 기록 (Trade History):**
        *   **테이블 형식**으로 시스템을 통해 체결된 모든 매매 기록을 최신순으로 표시한다.
        *   **컬럼:** `체결 시각`, `종목명`, `매매 종류(매수/매도)`, `체결 가격`, `체결 수량`, `매매 금액`, `관련 전략명`

---

## 7. 개발 로드맵

#### Phase 1: 백엔드 핵심 기반 구축
* **상태:** `[진행 중]`
* **목표:** 안정적인 데이터베이스 구조 위에서, 규칙을 포함한 복잡한 트레이딩 전략을 생성하고 조회하는 핵심 백엔드 기능을 완성합니다.
* **주요 작업:** 프로젝트 구조 설정, DB 모델링, 핵심 CRUD API 구현, 사용자 정의 지표 로딩 기능, Health-Check API 구현.

#### Phase 2: 스캔 엔진 및 API 기능 확장
* **상태:** `[예정]`
* **목표:** UI에서 만든 전략을 실제 스캔 엔진에 연결하고, 관리 기능을 완성합니다.
* **주요 작업:** 브로커 연동, 스캔 엔진 초기 버전 구현, 스캔 실행/중지 API 구현.

#### Phase 3: 프론트엔드 핵심 UI 및 실시간 스캔 기능 구현
* **상태:** `[예정]`
* **목표:** 전략을 만들고, 실행하며, 실시간 결과를 확인할 수 있는 핵심 UI를 완성합니다.
* **주요 작업:** 전략 빌더 UI, 실시간 스캔 현황 페이지, 웹소켓 연동.

#### Phase 4: 동적 1차 필터링 기능 구현
* **상태:** `[예정]`
* **목표:** 하드코딩된 1차 필터를 사용자가 직접 UI에서 동적으로 관리하는 기능으로 전환합니다.
* **주요 작업:** 동적 필터링 UI, 백엔드 모델 및 API 확장, 스캔 엔진 로직 추가.

#### Phase 5: 고급 스캔 제어 및 전략/스케줄 관리 시스템 완성
* **상태:** `[예정]`
* **목표:** 2-Phase 스캐너를 완벽하게 저장/로드하고, 스캔 작업을 중지하며, 다양한 조건으로 자동 실행할 수 있는 통합 제어 환경을 제공합니다.
* **주요 작업:** 백엔드 DB/API 재설계, 프론트엔드 전략 제어 및 스케줄 UI 구현, 스케줄러 연동.

#### Phase 6: 복합 논리 조건 엔진 (Architecture Change)
* **상태:** `[예정]`
* **목표:** `A and (B or C)` 와 같이 여러 규칙을 논리 그룹으로 묶을 수 있는 기능을 구현합니다.
* **주요 작업:** 규칙 Tree 구조를 위한 DB/API 재설계, 스캔 엔진 리팩토링, 프론트엔드 UI 재설계.

#### Phase 7: 다중 타임프레임 분석 엔진 (Engine Refactor)
* **상태:** `[예정]`
* **목표:** 하나의 전략 안에서 여러 시간 단위의 보조지표를 동시에 분석할 수 있는 기능을 구현합니다.
* **주요 작업:** DB 모델 확장, 스캔 엔진 고도화, UI에 타임프레임 지정 기능 추가.

#### Phase 8: 분석 및 실전매매 기능 고도화
* **상태:** `[예정]`
* **목표:** 실전 변수를 고려한 리스크 관리와 전략 검증 기능을 구현합니다.
* **주요 작업:** 이벤트 기반 백테스팅 엔진, 고급 전략 검증, 리스크/자금 관리 시스템 구현.

#### Phase 9: 시스템 확장 및 생태계 구축
* **상태:** `[예정]`
* **목표:** 주식 등 다른 자산군을 지원하고, 사용자들이 참여하고 기여할 수 있는 기반을 마련합니다.
* **주요 작업:** 다중 브로커 지원 확장, 플러그인 아키텍처 완성, 배포 편의성 강화.

#### Phase 10: 스캔 히스토리 및 분석
* **상태:** `[예정]`
* **목표:** 과거 스캔 결과를 저장하고 조회하여, 전략의 유효성을 검토할 수 있는 기반을 마련합니다.
* **주요 작업:** `ScanResult` DB 모델링, 히스토리 조회 API 및 UI 구현.

#### Phase 11: 상태 기반(Stateful) 스캔 엔진 구현
* **상태:** `[예정]`
* **목표:** '트리거-액션' 모델을 도입하여 고차원적인 스캔 기능을 구현합니다.
* **주요 작업:** `TriggeredSymbols` DB 모델링, UI/API 설계, 별도 '액션 스캐너' 구현.

---

## 8. 핵심 구현 가이드라인 및 기술 결정 사항

> **경고:** 이 섹션의 내용은 과거 프로젝트에서 얻은 값비싼 교훈의 산물입니다. 새 프로젝트의 모든 개발자는 **반드시 이 가이드라인을 숙지하고 준수해야 합니다.**

1. **보조지표(Indicator) 개발 지침:**
- **플러그인 표준:** 각 지표 파일은 `INDICATORS` 딕셔너리를 `export`해야 하며, `{"지표명": {"function": 함수, "metadata": 메타데이터}}` 구조를 따라야 합니다.
- **파라미터 타입 안정성:** 지표 함수 내부에서 숫자 파라미터를 `float(param)`처럼 **명시적으로 타입을 변환**해야 합니다.
- **Polars 연산 스타일 통일:** 가급적 `with_columns`와 `pl.col()`을 사용하는 **`Expression` 스타일로 작성하여 일관성을 유지**해야 합니다.

2. **비동기(Async) 및 데이터베이스(DB) 처리 지침:**
- **Eager Loading 원칙:** SQLAlchemy 비동기 세션 사용 시, `selectinload` 옵션을 사용하여 즉시 로딩하는 것을 원칙으로 합니다.
- **독립적인 Broker 사용:** 각 API 엔드포인트나 백그라운드 작업은 `async with Broker() as broker:` 구문을 통해 독립적인 인스턴스를 생성하고 관리해야 합니다.
- **안전한 프로세스 중지:** 백그라운드 작업 제어는 강제 종료가 아닌, 작업 스스로 상태 플래그를 확인하고 안전하게 종료하는 **'협력적 멀티태스킹' 방식**을 따라야 합니다.

3. **프론트엔드 및 API 연동 지침:**
- **CORS 설정:** 개발 초기 단계에 `main.py`에 `CORSMiddleware`를 설정하여 프론트엔드 개발 서버를 허용해야 합니다.
- **API 응답 데이터 검증:** 프론트엔드에서는 API로부터 받은 데이터의 속성 및 타입을 항상 확인해야 합니다.

4. **시스템 검증 지침:**
- **백엔드 지표 플러그인 검증:** 백엔드 서버 실행 시, 모든 지표 플러그인의 유효성이 자동으로 검사됩니다.
- **프론트엔드 코드 검증:** `frontend` 디렉토리에서 `npm run build` 명령어를 수동으로 실행하여 타입 검사 및 빌드 유효성을 검증해야 합니다.

---

## 9. 부록

### 9.1. 초기 설치 및 실행 가이드

1. **시스템 요구사항:** Python 3.10+, Node.js 18+
2. **백엔드 설정:** 가상환경 생성 후 `pip install -r requirements.txt` 실행, `.env` 파일에 API 키 설정.
3. **프론트엔드 설정:** `frontend` 디렉토리에서 `npm install` 실행.
4. **실행:**
- 백엔드: `uvicorn app.main:app --reload`
- 프론트엔드: `cd frontend && npm run dev`
- 브라우저에서 `http://localhost:5173` 접속.

### 9.2. 기술 사양 및 데이터 표준

#### 9.2.1. 데이터 컬럼 표준
- **목표:** 여러 거래소(브로커)를 지원하기 위해, 애플리케이션 내부에서 사용하는 데이터 컬럼명을 표준화합니다.
- **표준:**
- **종가 (Closing Price):** `close`
- **시가 (Opening Price):** `open`
- **고가 (High Price):** `high`
- **저가 (Low Price):** `low`
- **거래량 (Volume):** `volume`
- **거래대금 (Trading Amount):** `amount`
- **책임:**
- **브로커 (`app/core/brokers/*.py`):** 각 브로커는 거래소 API로부터 받은 데이터를 이 표준 컬럼명(`close`, `open` 등)에 맞게 '번역'하여 시스템에 제공할 책임이 있습니다.
- **보조지표 플러그인 (`plugins/indicators/*.py`):** 모든 보조지표는 이 내부 표준 데이터 컬럼명을 기반으로 작성되어야 합니다.

#### 9.2.2. 숫자 입력 및 처리 표준
* **소수점 지원:** 시스템 내 모든 숫자 입력 필드(지표 파라미터, 조건 값 등)는 **반드시 소수점 입력을 지원하고 처리**해야 한다.

#### 9.2.3. 데이터 표시 단위 표준
* **거래량 (Volume):** 차트, 테이블 등 모든 표시 영역에서 **'만' 단위를 기본**으로 하며, 소수점 둘째 자리까지 표현한다. (예: 12,345주는 `1.23만`으로 표시)
* **거래대금 (Amount):**
* 모든 표시 영역에서 **'억' 단위를 기본**으로 하며, 소수점 둘째 자리까지 표현한다. (예: 1,234,567,890원은 `12.34억`으로 표시)
* **원화(KRW) 환산 표시:** 해외 시장(예: 미국 주식)의 거래대금 또한, 조회 시점의 실시간 환율을 적용하여 **원화(KRW) 가치로 환산된 금액을 기준**으로 '억' 단위로 표시한다. 이를 통해 사용자는 모든 자산의 규모를 직관적으로 비교할 수 있다.

### 9.3. 표현식 및 변수 처리 규칙
* **표현식 평가:** 사용자가 `trix(12) - trix_signal(9) > 0` 와 같이 작성한 복합 표현식은 백엔드 `LogicParser`가 각 함수를 실행하고 그 결과를 바탕으로 최종 연산을 수행한다.
* **변수 처리:** 사용자가 `my_var = (high + low) / 2` 와 같이 변수를 정의하면, `LogicParser`는 다른 표현식에서 `my_var`가 나타날 때 이를 `(high + low) / 2`로 치환하여 계산한다.
* **문법 제약:** `trix(12).shift(1)`과 같이 함수 호출에 직접 `.`을 붙여 다른 함수를 호출하는 것은 금지된다. 이 경우, 반드시 `trix12 = trix(12)`와 같이 변수로 먼저 정의한 후 `trix12.shift(1)` 형태로 사용해야 한다.

### 9.4. 사용자 피드백 기반 개선 및 신규 기능 로드맵 (2025-11-04)

- **'다른 이름으로 저장' 기능:** 전략 및 스케줄을 새로운 이름으로 복제 저장하는 기능. `[요청됨]`
- **전략 빌더 표현식 UI 추가:** `shift(n)`, `cross_up()`, `cross_down()` 함수 입력 UI. `[요청됨]`
- **검색 결과 종목 수 표시:** 스캔 결과 패널 상단에 "Found N tickers" 표시. `[요청됨]`
- **스케줄 동작 방식 명확화:** 실행 시간이 스캔 소요 시간보다 짧을 경우, 이전 작업이 끝나기 전까지 다음 작업은 대기함. (APScheduler `max_instances=1` 기본 동작)